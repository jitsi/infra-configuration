---
# install prerequisite packages
- name: install videobridge prereqs
  apt:
    name: ["authbind","jq","mc","stress","vim","htop"]
    state: present

- name: install monitoring pip prereqs - decorator
  pip: name=decorator state=present
  when: ansible_distribution_release == 'focal' or ansible_distribution_release == 'jammy'

- name: freeze check pip pre reqs
  pip: name=datadog state=present
  when: ansible_distribution_release == 'focal' or ansible_distribution_release == 'jammy'

- name: install monitoring pip prereqs - decorator
  pip: name=decorator version="4.4.2" state=present executable=/usr/bin/pip
  when: ansible_distribution_release == 'bionic'

# datadog python module only works with pip, not pip3
# this script is sometimes run with ansible_python_interpreter=/usr/bin/python3
# and then, unless the executable path is set, it will use pip3
- name: freeze check pip pre reqs
  pip: name=datadog state=present executable=/usr/bin/pip
  when: ansible_distribution_release == 'bionic'

# begin install of intended jvb package
- name: mark unhold on jitsi-videobridge package version
  command: apt-mark unhold {{ jitsi_videobridge_deb_pkg_name }}

- name: install jitsi-videobridge package
  apt: name="{{ jitsi_videobridge_deb_pkg_name }}={{ jitsi_videobridge_deb_pkg_version }}" state=present
  notify:
    - restart jitsi-videobridge
  when: ansible_service_mgr != "systemd"

- name: install jitsi-videobridge package
  apt: name="{{ jitsi_videobridge_deb_pkg_name }}={{ jitsi_videobridge_deb_pkg_version }}" state=present
  notify:
    - restart jitsi-videobridge systemd
  when: ansible_service_mgr == "systemd"

- name: mark hold on JVB package version
  command: apt-mark hold {{ jitsi_videobridge_deb_pkg_name }}

#set the UDP receive buffer and max packet count higher
- name: JVB udp buffer limits
  template: dest="/etc/sysctl.d/20-jvb-udp-buffers.conf" src="jvb-udp-buffers.conf.j2" owner=root group=root mode=0644

#set the PAM limits to allow more open files for JVB user
- name: JVB file open limits
  copy: dest="/etc/security/limits.d/jvb.conf" content="jvb - nofile {{ jvb_open_file_limit }}\nroot - nofile {{ jvb_open_file_limit }}\njvb soft core unlimited\nroot soft core unlimited\n"
- name: PAM common session applies limits
  lineinfile: dest=/etc/pam.d/common-session line="session required\tpam_limits.so"
- name: PAM common noninteractive-session applies limits
  lineinfile: dest=/etc/pam.d/common-session-noninteractive line="session required\tpam_limits.so"

#set the systemd limits for threads per user
- name: systemd UserTasksMax setting
  lineinfile: dest=/etc/systemd/logind.conf line="UserTasksMax=80%" regexp="UserTasksMax="
  when: ansible_service_mgr == "systemd"

#set the systemd limits for default threads
- name: systemd DefaultTasksMax setting
  lineinfile: dest=/etc/systemd/system.conf line="DefaultTasksMax=30405" regexp="DefaultTasksMax="
  when: ansible_service_mgr == "systemd"

#provide script for managing the auto-scale group lifecycle queue
- name: lifecyle script upload
  copy: dest="/usr/local/bin/monitor-terminating-instance.sh" src="monitor-terminating-instance.sh" mode=755 owner=root

- name: lifecyle script systemd
  copy: dest="/etc/systemd/system/monitor-terminating-instance.service" src="monitor-terminating-instance.service" mode=644 owner=root

- name: Copy terminate instance script oracle
  template: src="terminate_instance_oracle.j2" dest="{{ jvb_path_to_terminate_instance_script }}" owner="{{ jvb_username }}" group=jitsi mode=0755
  when: jvb_cloud_provider == "oracle"

# add a health checker script to upload health stats to CloudWatch
- name: JVB health check script upload
  copy: dest={{ path_to_health_script }} src="jvb-health-check.sh" mode=755 owner=root
  when: jvb_cloud_provider == "aws"

# add a health checker script
- name: JVB health check script upload
  copy: dest={{ path_to_health_script }} src="jvb-health-check-oracle.sh" mode=755 owner=root
  when: jvb_cloud_provider == "oracle"

# add a stats script to wrap DD colibri script
- name: JVB stats script upload aws
  copy: dest={{ path_to_stats_script }} src="jvb-stats.sh" mode=755 owner=root
  when: jvb_cloud_provider == "aws"

- name: JVB stats script upload oracle
  copy: dest={{ path_to_stats_script }} src="jvb-stats-oracle.sh" mode=755 owner=root
  when: jvb_cloud_provider == "oracle"

# add a stats script to upload colibri stats to DataDog
- name: JVB stats python script upload
  copy: dest={{ path_to_stats_python_script }} src="jvb-stats.py" mode=755 owner=root

#provide bash script for last minute final configuration based on AWS tags
- name: postinstall script upload aws
  template: dest="/usr/local/bin/postinstall-jvb.sh" src="postinstall-jvb.sh.j2" mode=755 owner=root
  when: jvb_cloud_provider == "aws"

- name: postinstall script upload oracle
  template: dest="/usr/local/bin/postinstall-jvb-oracle.sh" src="postinstall-jvb-oracle.sh.j2" mode=755 owner=root
  when: jvb_cloud_provider == "oracle"

#provide bash script for last minute final configuration via ansible
- name: postinstall second script upload aws
  copy: dest="/usr/local/bin/configure-jvb-local.sh" src="configure-jvb-local.sh" mode=755 owner=root
  when: jvb_cloud_provider == "aws"

- name: postinstall second script upload oracle
  copy: dest="/usr/local/bin/configure-jvb-local-oracle.sh" src="configure-jvb-local-oracle.sh" mode=755 owner=root
  when: jvb_cloud_provider == "oracle"

#script to configure the secondary VNIC
- name: coturn configure secondary vnic oracle
  copy: dest="/usr/local/bin/secondary_vnic_all_configure_oracle.sh" src="secondary_vnic_all_configure_oracle.sh" mode=755 owner=root
  when: jvb_cloud_provider == "oracle"

# Stop the service if we are  building an AMI
- name: stop JVB for image
  service: name="{{ jvb_systemd_service_name }}" state=stopped enabled=no
  when: jvb_image_build_flag

# Clear logs for JVB if we are  building an AMI
- name: delete JVB logs for image
  file: path=/var/log/jitsi/jvb.log state=absent
  when: jvb_image_build_flag

# Clear PID for JVB if we are  building an AMI
- name: delete JVB pid for image
  file: path=/var/run/jitsi-videobridge/jitsi-videobridge.pid state=absent
  when: jvb_image_build_flag

- name: authbind directory
  file: path=/etc/authbind owner=root mode=0755 state=directory

- name: authbind byport directory
  file: path=/etc/authbind/byport owner=root mode=0755 state=directory

- name: JVB authbind item
  copy: dest=/etc/authbind/byport/443 content="" mode=0755 owner="{{ jvb_username }}"

- name: YourKit Installer
  unarchive:
    src: "{{ jvb_yourkit_url }}"
    dest: /opt
    remote_src: True
  when: jvb_download_yourkit

    #force restart of jitsi-videobridge even if not updated
# - debug: trigger jitsi-videobridge
#   notify: restart jitsi-videobridge
#   changed_when: true
